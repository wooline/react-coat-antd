import { Icon, Menu } from "antd";
import RootState from "core/RootState";
import { MenuItemData } from "modules/admin/model/type";
import pathToRegexp from "path-to-regexp";
import React from "react";
import { connect } from "react-redux";
import { Link } from "react-router-dom";
import { Dispatch } from "redux";

const { SubMenu } = Menu;

interface Props {
  collapsed: boolean;
  dataSource: MenuItemData[];
  pathname: string;
}

interface State {
  openKeys: string[];
}

interface OwnProps {}

function mapMenuData(menus: MenuItemData[]) {
  const maps: { [key: string]: string[] } = {};
  const ends: string[] = [];
  const checkData = (item: MenuItemData, parent?: string) => {
    if (!maps[item.path]) {
      maps[item.path] = [];
    }
    if (parent) {
      maps[item.path].push(parent, ...maps[parent]);
    }
    if (item.children && item.children.length) {
      item.children.forEach(subItem => checkData(subItem, item.path));
    } else {
      ends.push(item.path);
    }
  };
  menus.forEach(subItem => checkData(subItem));
  return ends.reduce((pre, cur) => {
    pre[cur] = maps[cur];
    return pre;
  }, {});
}

class Component extends React.PureComponent<Props, State> {
  flatMenuKeys: string[] = [];
  menus: { [key: string]: string[] };
  constructor(props: Props) {
    super(props);
    this.flatMenuKeys = this.getFlatMenuKeys(props.dataSource);
    this.menus = mapMenuData(props.dataSource);
    this.state = {
      openKeys: getSelectedMenuKeys(this.flatMenuKeys, this.props.pathname),
    };
  }

  /**
   * Recursively flatten the data
   * [{path:string},{path:string}] => {path,path2}
   * @param  menus
   */
  getFlatMenuKeys(menus: MenuItemData[]) {
    let keys: string[] = [];
    menus.forEach(item => {
      if (item.children) {
        keys = keys.concat(this.getFlatMenuKeys(item.children));
      }
      keys.push(item.path);
    });
    return keys;
  }
  componentWillReceiveProps(nextProps: Props) {
    if (nextProps.pathname !== this.props.pathname) {
      this.setState({
        openKeys: getSelectedMenuKeys(this.flatMenuKeys, nextProps.pathname),
      });
    }
  }

  handleOpenChange = (openKeys: string[]) => {
    const lastOpenKey = openKeys[openKeys.length - 1];
    const moreThanOne = openKeys.filter(openKey => this.props.dataSource.some(item => item.path === openKey)).length > 1;
    this.setState({
      openKeys: moreThanOne ? [lastOpenKey] : [...openKeys],
    });
  };
  render() {
    const { collapsed, pathname, dataSource } = this.props;
    const { openKeys } = this.state;
    // Don't show popup menu when it is been collapsed
    const menuProps = collapsed ? {} : { openKeys };
    // if pathname can't match, use the nearest parent's key
    let selectedKeys = getSelectedMenuKeys(this.flatMenuKeys, pathname);
    if (!selectedKeys.length) {
      selectedKeys = [openKeys[openKeys.length - 1]];
    }
    return (
      <Menu key="Menu" theme="dark" mode="inline" {...menuProps} onOpenChange={this.handleOpenChange} selectedKeys={selectedKeys} style={{ padding: "16px 0", width: "100%" }}>
        {getNavMenuItems(dataSource, pathname)}
      </Menu>
    );
  }
}

const mapStateToProps = (state: RootState, ownProps: OwnProps) => {
  const layout = state.project.admin;
  return {
    collapsed: layout.siderCollapsed,
    dataSource: layout.menuData,
    pathname: state.router.location.pathname,
  };
};
const mapDispatchToProps = (dispatch: Dispatch<any>, ownProps: OwnProps) => {
  return {};
};
export default connect(mapStateToProps, mapDispatchToProps)(Component);

function conversionPath(path: string) {
  if (path && path.indexOf("http") === 0) {
    return path;
  } else {
    return `/${path || ""}`.replace(/\/+/g, "/");
  }
}

// /userinfo/2144/id => ['/userinfo','/useinfo/2144,'/userindo/2144/id']
function urlToList(url: string) {
  const urllist = url.split("/").filter(i => i);
  return urllist.map((urlItem, index) => {
    return `/${urllist.slice(0, index + 1).join("/")}`;
  });
}

function getMeunMatcheys(flatMenuKeys: string[], path: string) {
  return flatMenuKeys.filter(item => {
    const reg = pathToRegexp(item);
    return reg.test(path);
  });
}

/**
 * 判断是否是http链接.返回 Link 或 a
 * Judge whether it is http link.return a or Link
 * @memberof SiderMenu
 */
function getMenuItemPath(item: MenuItemData, curPathname: string) {
  const itemPath = conversionPath(item.path);
  const icon = getIcon(item.icon);
  const { target, name } = item;
  // Is it a http link
  if (/^https?:\/\//.test(itemPath)) {
    return (
      <a href={itemPath} target={target}>
        {icon} <span>{name}</span>
      </a>
    );
  }
  return (
    <Link to={itemPath} target={target} replace={itemPath === curPathname}>
      {icon} <span>{name}</span>
    </Link>
  );
}

/**
 * 获得菜单子节点
 * @memberof SiderMenu
 */
function getNavMenuItems(menusData: MenuItemData[], curPathname: string) {
  return menusData.map(item => {
    if (item.children) {
      return (
        <SubMenu
          title={
            item.icon ? (
              <span>
                {getIcon(item.icon)}
                <span>{item.name}</span>
              </span>
            ) : (
              item.name
            )
          }
          key={item.path}
        >
          {getNavMenuItems(item.children, curPathname)}
        </SubMenu>
      );
    } else {
      return <Menu.Item key={item.path}>{getMenuItemPath(item, curPathname)}</Menu.Item>;
    }
  });
}

// Get the currently selected menu
// /list/search/articles = > ['list','/list/search']
function getSelectedMenuKeys(flatMenuKeys: string[], pathname: string) {
  const arr = urlToList(pathname);
  return arr
    .map(itemPath => {
      const arr2 = getMeunMatcheys(flatMenuKeys, itemPath);
      return arr2[0];
    })
    .filter(item => item);
}

// Allow menu.js config icon as string or ReactNode
//   icon: 'setting',
//   icon: 'http://demo.com/icon.png',
//   icon: <Icon type="setting" />,
function getIcon(icon: string | undefined) {
  if (typeof icon === "string" && icon.indexOf("http") === 0) {
    return <img src={icon} alt="icon" className="icon sider-menu-item-img" />;
  }
  if (typeof icon === "string") {
    return <Icon type={icon} />;
  }
  return icon;
}
